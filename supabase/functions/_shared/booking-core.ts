/**
 * Shared Booking Creation Logic
 * 
 * Core functions used by both authenticated and guest booking flows.
 * PR5: Edge Function Deduplication - Consolidates duplicated logic
 */

import { getAdminClient } from "./auth.ts";
import { sanitizePhone } from "./cors.ts";

export interface BookingInput {
  userId: string;
  vehicleId: string;
  locationId: string;
  startAt: string;
  endAt: string;
  dailyRate: number;
  totalDays: number;
  subtotal: number;
  taxAmount: number;
  depositAmount: number;
  totalAmount: number;
  driverAgeBand: string;
  youngDriverFee?: number;
  notes?: string;
  status?: "pending" | "confirmed";
  pickupAddress?: string;
  pickupLat?: number;
  pickupLng?: number;
  pickupContactName?: string;
  pickupContactPhone?: string;
  specialInstructions?: string;
  saveTimeAtCounter?: boolean;
  // Card info (last 4 digits only for display, never full card)
  cardLastFour?: string;
  cardType?: string;
  cardHolderName?: string;
}

export interface AddOnInput {
  addOnId: string;
  price: number;
  quantity: number;
}

export interface AdditionalDriverInput {
  driverName: string | null;
  driverAgeBand: string;
  youngDriverFee: number;
}

export interface BookingResult {
  success: boolean;
  booking?: {
    id: string;
    bookingCode: string;
    status: string;
  };
  error?: string;
  errorCode?: string;
}

/**
 * Check for conflicting bookings
 */
export async function checkBookingConflicts(
  vehicleId: string,
  startAt: string,
  endAt: string
): Promise<boolean> {
  const supabase = getAdminClient();
  
  const { data: conflicts } = await supabase
    .from("bookings")
    .select("id")
    .eq("vehicle_id", vehicleId)
    .in("status", ["pending", "confirmed", "active"])
    .or(`and(start_at.lte.${endAt},end_at.gte.${startAt})`)
    .limit(1);
  
  return !!(conflicts && conflicts.length > 0);
}

/**
 * Validate driver age band
 */
export function isValidAgeBand(ageBand: string | undefined): boolean {
  return !!ageBand && ["21_25", "25_70"].includes(ageBand);
}

/**
 * Create booking record
 */
export async function createBookingRecord(input: BookingInput): Promise<BookingResult> {
  const supabase = getAdminClient();
  
  const { data: booking, error } = await supabase
    .from("bookings")
    .insert({
      user_id: input.userId,
      vehicle_id: input.vehicleId,
      location_id: input.locationId,
      start_at: input.startAt,
      end_at: input.endAt,
      daily_rate: input.dailyRate,
      total_days: input.totalDays,
      subtotal: input.subtotal,
      tax_amount: input.taxAmount,
      deposit_amount: input.depositAmount,
      total_amount: input.totalAmount,
      booking_code: "", // Generated by trigger
      status: input.status || "confirmed",
      notes: input.notes?.slice(0, 1000) || null,
      driver_age_band: input.driverAgeBand,
      young_driver_fee: input.youngDriverFee || 0,
      pickup_address: input.pickupAddress?.slice(0, 500) || null,
      pickup_lat: input.pickupLat || null,
      pickup_lng: input.pickupLng || null,
      pickup_contact_name: input.pickupContactName?.slice(0, 100) || null,
      pickup_contact_phone: sanitizePhone(input.pickupContactPhone || "") || null,
      special_instructions: input.specialInstructions?.slice(0, 500) || null,
      save_time_at_counter: input.saveTimeAtCounter || false,
      card_last_four: input.cardLastFour?.slice(0, 4) || null,
      card_type: input.cardType?.slice(0, 20) || null,
      card_holder_name: input.cardHolderName?.slice(0, 255) || null,
    })
    .select()
    .single();
  
  if (error) {
    console.error("Error creating booking:", error);
    return {
      success: false,
      error: "Failed to create booking",
      errorCode: "booking_failed",
    };
  }
  
  return {
    success: true,
    booking: {
      id: booking.id,
      bookingCode: booking.booking_code,
      status: booking.status,
    },
  };
}

/**
 * Create booking add-ons
 */
export async function createBookingAddOns(
  bookingId: string,
  addOns: AddOnInput[]
): Promise<void> {
  if (!addOns || addOns.length === 0) return;
  
  const supabase = getAdminClient();
  
  const addOnRecords = addOns.slice(0, 10).map((addon) => ({
    booking_id: bookingId,
    add_on_id: addon.addOnId,
    price: addon.price,
    quantity: Math.min(addon.quantity, 10),
  }));
  
  await supabase.from("booking_add_ons").insert(addOnRecords);
}

/**
 * Create additional drivers
 */
export async function createAdditionalDrivers(
  bookingId: string,
  drivers: AdditionalDriverInput[]
): Promise<void> {
  if (!drivers || drivers.length === 0) return;
  
  const supabase = getAdminClient();
  
  const driverRecords = drivers.slice(0, 5).map((driver) => ({
    booking_id: bookingId,
    driver_name: driver.driverName?.slice(0, 100) || null,
    driver_age_band: driver.driverAgeBand,
    young_driver_fee: driver.youngDriverFee || 0,
  }));
  
  await supabase.from("booking_additional_drivers").insert(driverRecords);
}

/**
 * Send booking notifications (fire-and-forget)
 */
export function sendBookingNotifications(params: {
  bookingId: string;
  bookingCode: string;
  customerName?: string;
  vehicleName?: string;
  isGuest?: boolean;
}): void {
  const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
  const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
  
  const sendNotification = async (endpoint: string, body: Record<string, unknown>) => {
    try {
      await fetch(`${supabaseUrl}/functions/v1/${endpoint}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${supabaseServiceKey}`,
        },
        body: JSON.stringify(body),
      });
    } catch (err) {
      console.error(`Notification ${endpoint} failed:`, err);
    }
  };
  
  // Fire all notifications in parallel, don't wait
  Promise.all([
    sendNotification("send-booking-email", {
      bookingId: params.bookingId,
      templateType: "confirmation",
    }),
    sendNotification("send-booking-sms", {
      bookingId: params.bookingId,
      templateType: "confirmation",
    }),
    sendNotification("notify-admin", {
      eventType: "new_booking",
      bookingId: params.bookingId,
      bookingCode: params.bookingCode,
      customerName: params.customerName || "Customer",
      vehicleName: params.vehicleName || "",
      isGuest: params.isGuest || false,
    }),
  ]).catch(console.error);
}
